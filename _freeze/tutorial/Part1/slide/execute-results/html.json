{
  "hash": "b0a6df56e0c90f549ce3416466490c98",
  "result": {
    "markdown": "---\ntitle: \"TutoRial - Part 1\"\nsubtitle: \"Marine Ecosystem Dynamics\"\nauthor:\n  - \"Kinlan Jan\"\n  - \"Baptiste Serandour\"\nformat:\n  html:\n    html-math-method: katex\n    toc: true\n    toc-depth: 3\n---\n\n::: {.cell}\n\n:::\n\n\n## New script\n\nAs seen during the presentation, we will keep track of our progress. We thus need to open a new script following one of the option below.\n\n\n```{mermaid}\nflowchart LR\n  A[1. File] --> B[2. New File]\n  B --> C[3. R script]\n```\n\n```{mermaid}\nflowchart LR\n  A[\"⌘/Ctlr + ⇧ + N\"]\n```\n\n\n## **R** syntax\n\n**R** is a programming language that use a simplified syntax. In this section, you will explore how to write a script and execute it.\n\nBut first some syntax information:\n\n-   Everything after `#` is considered as a command and will not be executed. It is very important to write what we are doing, so we do not get lost next time we open our scripts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2 + 2 will not work because of the #\n2 + 2 # We should then annotate our script like this\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n-   Several lines of code can be written in one line but must be separated by\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 2\n3 * 2\n\n# This can also be written as follow:\n2 + 2 ; 3 * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n[1] 6\n[1] 4\n[1] 6\n```\n:::\n:::\n\n\n-   In **R** we can name a function, vector, or other object using `=` or `<-`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, 2, 3, 4)\nmy_function = function(x){x + 2}\n```\n:::\n\n\n-   `==` is a logical function that can be translated as *is equal to*, contrarily *is not equal to* is written `!=`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 2 == 4\n3 * 2 == 4\n3 * 2 != 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n[1] FALSE\n[1] TRUE\n```\n:::\n:::\n\n\n### Exercises\n\n1.  Do these calculations in a new **R** script\n\n-   $\\ 2^7$\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n2^7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 128\n```\n:::\n:::\n\n:::\n\n-   $\\ cos(\\pi)$\n\n::: {.callout-tip collapse=\"true\" title=\"Hint\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n?cos()\n?pi()\n```\n:::\n\n:::\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ncos(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1\n```\n:::\n:::\n\n:::\n\n-   $\\ \\sum_{1}^{100} i$\n\n::: {.callout-tip collapse=\"true\" title=\"Hint\"}\nOperations can take place for an entire vector\n:::\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nvector <- seq(from = 1, to = 100, by = 1) # Create a vector from 1 to 100\nsum(vector) # Calculate the sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5050\n```\n:::\n:::\n\n:::\n\n2.  Create a parameter `x1` that equals to 5 and a parameter `x2` that equals to 10\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- 5 ; x2 <-  10\n```\n:::\n\n:::\n\n3.  Is 2`x1` equivalent to `x2`?\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n2*x1 == x2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n## Functions\n\nAs seen during the lecture, **R** works with functions that can:\n\n-   Already be implemented in base **R**\n-   Comming from another package\n-   Created by the user\n\nWe will see these three examples in this section, but first it is important to remember that the typical structure of a function is `function(argument_1, ...)`. It is impossible to remember what are all the argument, but fortunately **R** helps us:\n\n-   Using `help()` or `?`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(topic = \"sin\")\n?sin\n```\n:::\n\n\n<img src=\"../assets/images/Help_sin.png\" width=\"100%\"/>\n\n-   Using `example`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nsum> ## Pass a vector to sum, and it will add the elements together.\nsum> sum(1:5)\n[1] 15\n\nsum> ## Pass several numbers to sum, and it also adds the elements.\nsum> sum(1, 2, 3, 4, 5)\n[1] 15\n\nsum> ## In fact, you can pass vectors into several arguments, and everything gets added.\nsum> sum(1:2, 3:5)\n[1] 15\n\nsum> ## If there are missing values, the sum is unknown, i.e., also missing, ....\nsum> sum(1:5, NA)\n[1] NA\n\nsum> ## ... unless  we exclude missing values explicitly:\nsum> sum(1:5, NA, na.rm = TRUE)\n[1] 15\n```\n:::\n:::\n\n\nFor the functions that comes from another package, we first need to install the new packages. The most common way to do so is by executing `install.packages(\"Package_Name\")`. Then everytime you open a new session and you want to use the package, start the script by executing `library(Package_Name)`.\n\nFinally, if you really do not find a suitable function in a package, or want to create your own function, you can create your functions following this general structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_function <- function(<argument_1>, <argument_2>, ...){\n  <here comes the definition of my function>\n  return(<output of the definition>)\n}\n```\n:::\n\n\n### Exercises\n\n-   What is the function `log()` doing and from were does this function come from (base **R**, other packages)?\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n?log() #It takes the natural logarithm of the value, it comes from base R\nlog(10) \n```\n:::\n\n:::\n\n-   What are the mandatory arguments for the function `plot()`\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n?plot() # the coordinates points x and y are needed\n```\n:::\n\n:::\n\n-   Install the package named `readr` and load it\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readr\")\nlibrary(readr)\n```\n:::\n\n:::\n\n-   Is there help associated with the functions from a loaded package?\n\n::: {.callout-tip collapse=\"true\" title=\"Hint\"}\nThe function `read_csv` comes from this package\n:::\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n?read_csv # Yes, there is also help for the imported functions\n```\n:::\n\n:::\n\n::: {.callout title=\"Optional exercises\"}\n-   Create a function that print `Hello World!` when executing it\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nHello <- function(){\n  cat(\"Hello World!\") # print(\"Hello World!\") works too\n}\nHello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\n```\n:::\n:::\n\n:::\n\n-   Create a function that multiply the input by 4\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplyeR <- function(x, y = 4){\n  return(x * y)\n}\nmultiplyeR(x = 2) # It works with values\nmultiplyeR(x = seq(1, 3, 1)) # But also vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n[1]  4  8 12\n```\n:::\n:::\n\n:::\n:::\n\n## Vectors\n\n**R** works with vector from which we can do our calculations. There is several way to create a vector:\n\n-   Using `c()` values are added next to each other\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 1, 4) # It works with integers (round numbers)\nc(1.1, 2.4, pi) # It works with floats (decimal numbers)\nc(\"chocolate\", \"ice-cream\") # It works with character\nc(TRUE, FALSE) # It works with logical variables\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 1 4\n[1] 1.100000 2.400000 3.141593\n[1] \"chocolate\" \"ice-cream\"\n[1]  TRUE FALSE\n```\n:::\n:::\n\n\n-   Using `rep()` to repeat the same values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(3, 2) # It works with integers\nrep(3.2, 3) # It works with floats\nrep(\"chocolate\", 2) # It works with character\nrep(TRUE, 3) # It works with logical variables\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n[1] 3.2 3.2 3.2\n[1] \"chocolate\" \"chocolate\"\n[1] TRUE TRUE TRUE\n```\n:::\n:::\n\n\n-   For numeric values (integers and floats) we can also use `seq` that produce a sequence from a value to another one\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 2, to = 6, by = 2)\nseq(from = 0, to = 1, by = 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6\n[1] 0.0 0.2 0.4 0.6 0.8 1.0\n```\n:::\n:::\n\n\n::: callout-tip\nif you want to do a sequence using `by = 1` it is easier to write it like this: `from:to`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\nseq(from = 1, to = 10, by = 1) == 1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n:::\n\n-   Finally, we can also combine vector together\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(2, 1), seq(from = 2, to = 4, by = 0.5), rep(\"a\", 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2\"   \"1\"   \"2\"   \"2.5\" \"3\"   \"3.5\" \"4\"   \"a\"   \"a\"  \n```\n:::\n:::\n\n\n### Exercises\n\n-   Create a vector `v1` that contains the values 3, 5, 1, 2, 6\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(3, 5, 1, 2, 6)\n```\n:::\n\n:::\n\n-   Create a vector `v2` that contains four times the values 3, 5, 1, 2, 6\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nv2 <- rep(v1, 4)\n```\n:::\n\n:::\n\n-   Create a vector `v3` that repeats `TRUE`, `FALSE` 5 times\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nv3 <- rep(c(TRUE, FALSE), 5)\n```\n:::\n\n:::\n\n-   Create a vector `v4` that goes from 10 to 200\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nv4 <- 10:200\n```\n:::\n\n:::\n\n-   Create a vector `v5` that contains `v1`, `v2`, `v3` and 2 times `v4`\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nv5 <- c(v1, v2, v3, rep(v4, 2))\n```\n:::\n\n:::\n\n## Tibbles\n\nNow that we have seen how to create vectors, we can start combining them in a dataframe, called `tibble`.\n\n-   First, load (and install if it is not done `install.packages(\"tibble\")`) the`tibble` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\n?tibble\n```\n:::\n\n\n-   Second, fill a tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(Plankton_type = c(rep(\"Zooplankton\", 6), rep(\"Phytoplankton\", 6)),\n       Biomass = c(65, 12, 42, 51, 23, 72, 10, 11, 21, 14, 23, 13))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Plankton_type </th>\n   <th style=\"text-align:right;\"> Biomass </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Zooplankton </td>\n   <td style=\"text-align:right;\"> 65 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Zooplankton </td>\n   <td style=\"text-align:right;\"> 12 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Zooplankton </td>\n   <td style=\"text-align:right;\"> 42 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Zooplankton </td>\n   <td style=\"text-align:right;\"> 51 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Zooplankton </td>\n   <td style=\"text-align:right;\"> 23 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Zooplankton </td>\n   <td style=\"text-align:right;\"> 72 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Phytoplankton </td>\n   <td style=\"text-align:right;\"> 10 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Phytoplankton </td>\n   <td style=\"text-align:right;\"> 11 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Phytoplankton </td>\n   <td style=\"text-align:right;\"> 21 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Phytoplankton </td>\n   <td style=\"text-align:right;\"> 14 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Phytoplankton </td>\n   <td style=\"text-align:right;\"> 23 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Phytoplankton </td>\n   <td style=\"text-align:right;\"> 13 </td>\n  </tr>\n</tbody>\n</table>\n\n</div>\n:::\n:::\n\n\n-   Then, we can access the individual vector (or column of the tibble) using `$` or `[[]]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample <- tibble(Plankton_type = c(rep(\"Zooplankton\", 6), rep(\"Phytoplankton\", 6)),\n       Biomass = c(65, 12, 42, 51, 23, 72, 10, 11, 21, 14, 23, 13))\n\nexample$Plankton_type\nexample[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Zooplankton\"   \"Zooplankton\"   \"Zooplankton\"   \"Zooplankton\"  \n [5] \"Zooplankton\"   \"Zooplankton\"   \"Phytoplankton\" \"Phytoplankton\"\n [9] \"Phytoplankton\" \"Phytoplankton\" \"Phytoplankton\" \"Phytoplankton\"\n [1] 65 12 42 51 23 72 10 11 21 14 23 13\n```\n:::\n:::\n\n\n### Exercises\n\n-   Create a tibble named `df` that look like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table style='width:30%;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Genus </th>\n   <th style=\"text-align:left;\"> Station </th>\n   <th style=\"text-align:right;\"> Abundance </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Acartia </td>\n   <td style=\"text-align:left;\"> B1 </td>\n   <td style=\"text-align:right;\"> 65.6 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Centropages </td>\n   <td style=\"text-align:left;\"> B1 </td>\n   <td style=\"text-align:right;\"> 32.6 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Centropages </td>\n   <td style=\"text-align:left;\"> B1 </td>\n   <td style=\"text-align:right;\"> 68.8 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Acartia </td>\n   <td style=\"text-align:left;\"> B1 </td>\n   <td style=\"text-align:right;\"> 91.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Temora </td>\n   <td style=\"text-align:left;\"> B1 </td>\n   <td style=\"text-align:right;\"> 53.4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Temora </td>\n   <td style=\"text-align:left;\"> B1 </td>\n   <td style=\"text-align:right;\"> 89.6 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(Genus = c(\"Acartia\", \"Centropages\", \"Centropages\", \"Acartia\", \"Temora\", \"Temora\"),\n       Station = \"B1\",\n       Abundance = c(65.6, 32.6, 68.8, 91.0, 53.4, 89.6))\n```\n:::\n\n:::\n\n-   Create a vector `output` that correspond to the column `Abundance` of the tibble `df`\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\noutput <- df$Abundance # or df[[3]]\n```\n:::\n\n:::\n\n## Importing data\n\nOften, we are not preparing our dataset in **R**. Thus, importing dataset is essential to process our data. To do so, we will see how to use the `read_*` function from the `readr` package.\n\n::: callout-tip\nWhen saving our spreadsheet, it is always a good idea to save the document as *.csv*\n:::\n\nA typical data import look like this\n\n1.  Set the working directory with its absolute path. So every time you want to import/export, you can use the relative path writen as `./...`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"/Absolute/Path/To/Working/Directory\") \n```\n:::\n\n\n2.  Load the `readr` package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n```\n:::\n\n\n3.  Import you dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_csv(\"./The/relative/path/to/my/dataset.csv\")\n```\n:::\n\n\n4.  Examine the data if the importation worked well\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df)\n```\n:::\n\n\n### Exercises\n\n-   Import and inspect the dataset `zooplankton_seasonality.csv`\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplankton_seasonality <- read_csv(\"/Users/kinlan/OneDrive - Stockholm University/PhD/Teaching/MarineEcosystemDynamics2023/Tutorial/Data/zooplankton_seasonality.csv\")\nstr(plankton_seasonality)\n```\n:::\n\nor\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"/Users/kinlan/OneDrive - Stockholm University/PhD/Teaching/MarineEcosystemDynamics2023/Tutorial\")\nplankton_seasonality <- read_csv(\"./Data/zooplankton_seasonality.csv\")\nstr(plankton_seasonality)\n```\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\nSometimes it is tricky to import directly in the good format, so it might be better to specify that the new dataset is a `tibble`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplankton_seasonality <- as_tibble(plankton_seasonality)\nstr(plankton_seasonality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [2,956 × 7] (S3: tbl_df/tbl/data.frame)\n $ Month_abb  : chr [1:2956] \"Jan\" \"Jan\" \"Jan\" \"Jan\" ...\n $ Year       : num [1:2956] 2009 2009 2009 2009 2009 ...\n $ Station    : chr [1:2956] \"BY15\" \"BY31\" \"BY5\" \"BY15\" ...\n $ Coordinates: chr [1:2956] \"20.05000/57.33333\" \"18.23333/58.58812\" \"15.98333/55.25000\" \"20.05000/57.33333\" ...\n $ Group      : chr [1:2956] \"Copepoda\" \"Copepoda\" \"Copepoda\" \"Copepoda\" ...\n $ Taxa       : chr [1:2956] \"Acartia\" \"Acartia\" \"Acartia\" \"Centropages\" ...\n $ Biomass    : num [1:2956] 6.65 1.82 5.56 5.74 1.23 ...\n```\n:::\n:::\n\n:::\n\n-   How many rows and columns are there in this dataset?\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(plankton_seasonality)\nncol(plankton_seasonality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2956\n[1] 7\n```\n:::\n:::\n\n:::\n\n-   Write the dataset `df` that you created in your working directory\n\n::: {.callout-note collapse=\"true\" title=\"Solution\" appearance=\"simple\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(df, file = \"./Data/df.csv\")\n```\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}